Programming Language
------------------------------------
Programming Language means the language that we use to talk with Computers


Low-Level Language
------------------------------
These are the languages that are very close to the computer‚Äôs hardware. They are fast and efficient but harder for humans to read and write. 


Machine Language 
----------------------------
Machine language originated in the 1940s, consisting of a series of 0s and 1s. It means that Machine language is the language that is easily understood by computers, but hard for humans to understand. It's fast cause it is close to the hardware. and it's not portable.
Example: 10110010 11001011


Assembly Language
------------------------------
 Slightly easier than machine language because it uses mnemonics (short words) instead of pure binary.
 Example: MOV AX, 1 (moves value 1 into register AX)


High-Level Languages
---------------------------------
These languages are closer to human language, making them easier to read, write, and maintain.


Middle-Level Languages
------------------------------------
These are a mix of low-level and high-level languages. 
Example: C



Difference
------------------

________________________________________________________________________________
|     Level		|     Close to				| Human readability 	|    Speed       |          Example              |
|__________	|____________________________________________________________________ |
| Low-level	| Hardware				| Hard				| Very fast	| Machine, Assembly	|
| Middle-level	| Hardware & High-level		| Medium				| Fast		|   C                		    	|
| High-level     | Humans					| Easy				| Slower		| Python, Java, C++	|
|_______________________________________________________________________________ |


Variable
---------
A variable is a named storage location in a program that holds data. Its value can change during program execution, allowing the program to store, update, and use information when needed.

Example:
jilan = 10 //Here Jilan is a variable and it contains the value 10


String
----------
A string is a data type used to store sequences of characters. It represents text such as letters, words, or symbols and is treated as a single piece of data by the program.

Example:
String = "Mahim"  //Here 'Mahim' is character with a few character

‚ô¶Ô∏èString Literal: A string literal simply means a fixed piece of text written inside quotes in your code ‚Äî it‚Äôs the literal value of a string, not a variable or expression.


Data Type
----------------
A data type defines the kind of data a variable can store and determines how the computer will interpret and handle that data. It sets rules for the size, format, and type of operations allowed on the stored value.

Example:
integer   = 12
float     = 12.5
String    = "Mahim"
Character = 'c'
Boolean   = True/False


Conditional Statement
--------------------------
A conditional statement allows a program to make decisions by checking whether a condition is true or false. Based on the result, the program chooses a specific path or action to execute.

Example:

if(condition):
  statement
elif(condition):
  statement
else:
  statement


Loop
-------
A loop is a control structure that repeatedly executes a block of code as long as a certain condition is met. It helps automate repetitive tasks and reduces code duplication.

Example:
 
 for i in range(start,step,stop):
  statement


Function
----------
A function is a self-contained block of code designed to perform a specific operation. It improves code organization, reduces repetition, and allows tasks to be reused throughout a program.

Example:

 def FunctionName(parameter1,parameter2):
    statememt
  return answer


Array
----------
An array is a structured collection of multiple values stored under a single name, where each value is kept at a specific position (index). It helps manage lists of related data efficiently.

Exaple:

ArrayName = [1,2,3,6]


2d Array
------------
A 2D array is an array made up of other arrays, arranged in rows and columns. It is used to represent data in a grid-like structure and is useful for storing tabular or matrix-based data.

Exaple:

ArrayName = [
  [1,2,3,6],
  [3,6,5,8,9,6,3,5],
  [7,8,9,6,5,47,8,3,6,9,5]
]


Mountain Array
-------------------

A mountain array is a special type of array (or list) that first strictly increases to a peak element and then strictly decreases after that.

Example:

array = [2,3,6,9,4,2,1]

__visual__:    
                        9
                      6   4
                    3       2
                  2           1


Dictionary
----------------
In Python, a dictionary is a built-in data structure used to store data in key‚Äìvalue pairs.
It‚Äôs similar to a real-life dictionary, where a word (key) maps to its definition (value).
we can't use dictionary and List to key but can use all of them as a value

Example:

student = {
    "name": "Mahim",
    "age": 22,
    "department": "CSE"
    "Subject": ["Mechanics","BBA","Law"]
     12:True
}


Mutable and Immutable
--------------------------
‚ô¶Ô∏èMutable:
01. Objects that can be changed after creation.
02. Modifying them does not create a new object ‚Äî the original object is updated in place.
03. Examples: list, dict, set.

Example:-

marks = [80, 90, 58, 70, 60]
marks.sort()
print(marks)  // [58, 60, 70, 80, 90]

‚û°Ô∏è The same list marks was changed ‚Äî no new list was created.


‚ô¶Ô∏èImmutable:

01. Objects that cannot be changed once created.
02. Any ‚Äúchange‚Äù creates a new object in memory.
03. Examples: str, tuple, int, float.

Example:-

name = "Mahim"
name = name + " Khan"
print(name)  // Mahim Khan

‚û°Ô∏è A new string "Mahim Khan" was created; the old "Mahim" string was left unchanged.



Static Language
-------------------------
A static language is one where data types are fixed and checked before the program runs. This leads to early detection of type errors, stronger structure, and often better performance.

Example: C,C++,Java,C#,Swift,Go,Rust


Dynamic Language
----------------------------
A dynamic language checks and assigns data types while the program is running. It allows greater flexibility, easier coding, and faster development but may catch type errors later.

Example: Python,JavaScript,Ruby,PHP,Perl,Lua,MATLAB


Debugging
-----------
Debugging is the process of identifying, analyzing, and fixing errors or unexpected behavior in a program. It ensures the code runs correctly and helps improve program reliability and performance.


Flow-chart
--------------------
A flowchart is a visual diagram that shows the steps in a process using symbols and arrows. It‚Äôs a simple way to make complicated tasks easier to understand.

üßøWhat a flowchart includes
		‚¨áÔ∏è			     
‚û°Ô∏è Oval ‚Üí Start or end
‚û°Ô∏èRectangle ‚Üí Action or task
‚û°Ô∏èDiamond ‚Üí Decision (yes/no or true/false)
‚û°Ô∏èArrows ‚Üí Show the order of steps
‚û°Ô∏èParallelogram ‚Üí Input/Output


üßøWhat flowcharts are used for

‚û°Ô∏èExplaining how a system or program works
‚û°Ô∏èPlanning computer algorithms
‚û°Ô∏èShowing business or work processes
‚û°Ô∏èTroubleshooting or decision-making guides

Example (simple):

   [Start]
      |
      v
 [Get ingredients]
      |
      v
 [Cook food]
      |
      v
    [Eat]
      |
      v
    [End]



Pseudocode
----------------

Pseudocode is a simple, plain-language way of writing the steps of a program or algorithm without using real programming syntax.

It looks like code, but it‚Äôs not tied to any specific programming language‚Äîits purpose is to explain the logic clearly.

‚úÖ Why pseudocode is useful

‚ô¶Ô∏èHelps plan a program before writing real code
‚ô¶Ô∏èEasy to read and understand
‚ô¶Ô∏èFocuses on logic, not syntax
‚ô¶Ô∏èUseful for communicating ideas between people who know different programming languages

üß† What pseudocode looks like

START
  INPUT number1
  INPUT number2
  total ‚Üê number1 + number2
  OUTPUT total
END



Time and Space Complexity
------------------------------

Time and Space Complexity describe how efficient an algorithm is.
These two ideas help you understand how much time and memory your code needs when input size increases.

‚è±Ô∏è 1. Time Complexity (How fast your algorithm runs)

Time Complexity tells you how the running time changes as the size of input (n) grows.

‚≠ê Common Time Complexities

‚ô¶Ô∏èO(1) ‚Üí Constant time (super fast)
    Example: accessing an array element
‚ô¶Ô∏èO(n) ‚Üí Linear time
    Example: looping once over an array
‚ô¶Ô∏èO(n¬≤) ‚Üí Quadratic time
    Example: nested loops
‚ô¶Ô∏èO(log n) ‚Üí Logarithmic time
    Example: binary search
‚ô¶Ô∏èO(n log n) ‚Üí Good for sorting algorithms
    Example: merge sort, quicksort (average)

‚ú® Purpose:
To compare algorithms without running them.



The ceiling number
---------------------
A ceiling number is the smallest integer greater than or equal to a given number, essentially rounding up to the next whole number or multiple

Example: 

a = 12.32
a = 13 #This is after ceiling



Stable and Unstable sort
------------------------------


Stable Sort ‡¶ï‡ßÄ?

Stable sorting ‡¶Æ‡¶æ‡¶®‡ßá ‡¶π‡¶≤‡ßã ‚Äî
‡¶Ø‡¶¶‡¶ø ‡¶¶‡ßÅ‡¶ü‡¶ø ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡ßá‡¶∞ (element) ‡¶Æ‡¶æ‡¶® ‡¶è‡¶ï‡¶á ‡¶π‡ßü, ‡¶§‡¶æ‡¶π‡¶≤‡ßá sort ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞‡ßá‡¶ì ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶ï‡ßç‡¶∞‡¶Æ (order) ‡¶†‡¶ø‡¶ï ‡¶•‡¶æ‡¶ï‡ßá‡•§

‡¶Ö‡¶∞‡ßç‡¶•‡¶æ‡ßé, ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶ú‡¶ø‡¶®‡¶ø‡¶∏‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶Ü‡¶ó‡ßá ‡¶õ‡¶ø‡¶≤, ‡¶∏‡ßá‡¶ü‡¶æ sort ‡¶π‡¶ì‡ßü‡¶æ‡¶∞ ‡¶™‡¶∞‡ßá‡¶ì ‡¶Ü‡¶ó‡ßá ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§

üß© ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:

‡¶ß‡¶∞‡ßã ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶è‡¶á ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ‡¶ü‡¶æ ‡¶Ü‡¶õ‡ßá ‚Äî
[(80, "A"), (70, "B"), (80, "C")]


‚û°Ô∏è Stable sort:
‡¶Ü‡¶Æ‡¶∞‡¶æ marks ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡ßü‡ßÄ sort ‡¶ï‡¶∞‡¶¨‡ßã (‡¶õ‡ßã‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßú):
Stable sort ‡¶π‡¶≤‡ßá ‡¶´‡¶≤‡¶æ‡¶´‡¶≤:
[(70, "B"), (80, "A"), (80, "C")]


‚û°Ô∏è Unstable sort:
‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‚ÄúA‚Äù ‡¶Ü‡¶ó‡ßá ‡¶õ‡¶ø‡¶≤, ‡¶§‡¶æ‡¶á sort ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞‡ßá‡¶ì ‚ÄúA‚Äù ‡¶Ü‡¶ó‡ßá ‡¶Ü‡¶õ‡ßá‡•§
Unstable sort ‡¶π‡¶≤‡ßá ‡¶´‡¶≤‡¶æ‡¶´‡¶≤:
[(70, "B"), (80, "C"), (80, "A")]


‚ùå ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‚ÄúA‚Äù ‡¶Ü‡¶∞ ‚ÄúC‚Äù-‡¶è‡¶∞ ‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶™‡¶æ‡¶≤‡ßç‡¶ü‡ßá ‡¶ó‡ßá‡¶õ‡ßá‡•§

üîπ ‡¶ï‡ßá‡¶® Stable Sort ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞?

01. ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá sort ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡ßü (‡¶Ø‡ßá‡¶Æ‡¶®: ‡¶Ü‡¶ó‡ßá ‡¶®‡¶æ‡¶Æ, ‡¶™‡¶∞‡ßá ‡¶¨‡ßü‡¶∏)
02. ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶â‡¶™‡¶æ‡¶¶‡¶æ‡¶®‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶ï‡ßç‡¶∞‡¶Æ ‡¶†‡¶ø‡¶ï ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶ö‡¶æ‡¶ì




Recursion
--------------------

Recursion is a programming technique where a function calls itself to solve a problem.

It works by breaking a big problem into smaller versions of the same problem ‚Äî until it reaches a point where it no longer needs to call itself. That point is called the base case.


üß† A recursive case is the part of the function that:

01. Calls itself (the same function name appears inside the function).
02. Reduces the problem (each call works on a smaller or simpler version).
03. Moves toward the base case (so it eventually stops).


üîÅ Example Concept

Think of recursion like looking into two mirrors facing each other ‚Äî the reflection keeps repeating until it fades away (base case).

üß† Structure of a Recursive Function

Every recursive function has two key parts:
01. Base Case ‚Üí Stops the recursion (prevents infinite loop).
02. Recursive Case ‚Üí The function calls itself with a smaller input.

Example:

def factorial(n):
    if n == 1:       # Base case
        return 1
    else:             # Recursive case
        return n * factorial(n - 1)


How it works:

factorial(4)
‚Üí 4 * factorial(3)
‚Üí 4 * 3 * factorial(2)
‚Üí 4 * 3 * 2 * factorial(1)
‚Üí 4 * 3 * 2 * 1 = 24



‚öôÔ∏è Why Use Recursion

‚û°Ô∏èSolves problems that are naturally repetitive or hierarchical ‚Äî like:
01. Tree/graph traversal
02. Searching/sorting algorithms (like quicksort, mergesort)
03. Mathematical sequences (Fibonacci, factorial)
04. File system exploration

‚ö†Ô∏è Important

Recursion can lead to stack overflow if the base case is missing or wrong, because it keeps calling itself endlessly.
